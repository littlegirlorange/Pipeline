# -*- coding: utf-8 -*-
"""

Utilities needed to measue landmark distances of elastix and ants registration results.

@author: Yingli Lu
"""

def map_3d_pixel_to_physical_coordinates(input_file,pixel_coords):
    '''
    map 3d pixel coordinates to physical by reading image orientation, image position and pixel spacing from file
    intput_file: .mha or .mhd or .nifti ...
    pixel_coords: list [x,y,z]
    '''
    import numpy as np
    import os.path
    import sys

    if not os.path.exists(input_file):
        print(input_file+" not exist!")
        sys.exit(1)

    
    if input_file[-3:] == 'mha':
        lines=[]
        N=11
        f=open(input_file)
        for i in range(N):
            lines.append(f.next().strip())
        f.close()
    
        patient_image_orientation = [float(i) for i in lines[6][18:].split()] 
        patient_image_position = [float(i) for i in lines[7][9:].split()] 
        pixel_spacing = [float(i) for i in lines[10][17:].split()]                 
    elif input_file[-3:] == 'mhd':
        pass
    elif input_file[-3:] == 'nii':
        pass
    else:
        print("unknow format!")
        sys.exit(1)

    M = np.array( [ [patient_image_orientation[0]*pixel_spacing[0], patient_image_orientation[3]*pixel_spacing[1], patient_image_orientation[6]*pixel_spacing[2],  patient_image_position[0]], 
                     [patient_image_orientation[1]*pixel_spacing[0],  patient_image_orientation[4]*pixel_spacing[1], patient_image_orientation[7]*pixel_spacing[2],  patient_image_position[1]], 
                     [patient_image_orientation[2]*pixel_spacing[0],  patient_image_orientation[5]*pixel_spacing[1], patient_image_orientation[8]*pixel_spacing[2],  patient_image_position[2]], 
                     [0,                                   0,                                       0,   1 ] ] )
    
    coords_new = pixel_coords[:]
    coords_new.append(1)
    P = np.array(coords_new)
    mapped_coords=M.dot(P)[0:3]
    
    return list(mapped_coords)
    
    
def get_patientID_accessNumber_seriesNumber_landmarkName_coords_from_dicom_folder(input_folder):
    import dicom
    import fnmatch
    from dicom.filereader import InvalidDicomError
    
    '''
    get patient_id,accession_number,series_number,landmark_name,coordinates([x,y,z]) from dicom folder contains key image generated by clearCanvas and original dicom images
    return a sorted list [ [patient_id,accession_number,series_number,landmark_name,[x,y,z]] ] 
    '''
    import os
    
    #find all .dcm files
    matches = []
    match_criteria = '*.dcm'
    for path, dirnames, filenames in os.walk(input_folder):
      for filename in fnmatch.filter(filenames, match_criteria):
        matches.append(os.path.join(path, filename))
    
    l=[] #[ [patient_id,accession_number,series_number,landmark_name,[x,y,z]] ]
    for item in matches:
        try:
            filename = os.path.basename(item)
            if filename[0:5] == "2.25.": #clearCanvas key image filename start with 2.25.
                h=dicom.read_file(item)
                val = h.get((0x008,0x0016),None)
                if val:
                    if val.value=="1.2.840.10008.5.1.4.1.1.11.1": #Grayscale Softcopy Presentation State Storage SOP Class
                        for i in range(0,len(h[0x0070,0x0001].value)): #multiple sequence
                            x,y = h[0x0070,0x0001][i][0x0070,0x0008][0][0x0070,0x0014].value #(0070, 0014) Anchor Point  FL: [219.42855834960938, 277.7142333984375]
                            landmark_name = h[0x0070,0x0001][i][0x0070,0x0008][0][0x0070,0x0006].value
                            
                            #get which image the landmark drawn on                
                            image_instance_uid = h[0x0070,0x0001][0][0x0008,0x1140][0][0x0008,0x1155].value                
                            image_full_path = os.path.dirname(item)+os.sep+image_instance_uid+'.dcm'
                                            
                            hh=dicom.read_file(image_full_path)
                            z = int(hh.get((0x0020,0x0013),None).value) #instanceNumber
                            patient_id = hh.get((0x0010, 0x0020),None).value
                            accession_number= hh.get((0x0008, 0x0050),None).value
                            series_number =hh.get((0x0020,0x0011),None).value
        
                            l.append([patient_id,accession_number,series_number,landmark_name,[round(x,2),round(y,2),round(z,2)]])
        except IOError:
            print 'No such file: ' + image_full_path
        except InvalidDicomError:
            print 'Invalid Dicom file:' + item 
    
    l.sort()
    
    return l

    
def get_registration_tasklist(patientID_accessNumber_seriesNumber_landmarkName_coords,mha_directory):
    
    '''
    return a list [ [patient_id,landmark_name,fixed,fixed_coords,moving,moving_coords] ] used by registration
    
    '''
    import os
    
    registration_tasklist=[] # [ [patient_id1,landmark_name1,fixed,fixed_coords,moving,moving_coords]) ]
    
    l = patientID_accessNumber_seriesNumber_landmarkName_coords
    
    for i in range(0,len(l)):
        patient_id1 = l[i][0]
        accession_number1 = l[i][1]
        series_number1 = l[i][2]
        landmark_name1 = l[i][3]
        landmark_coords1 = l[i][4]
        
        if not landmark_name1 == ' ': # landmark name not empty
            for j in range(i,len(l)):
                    patient_id2 = l[j][0]
                    accession_number2 = l[j][1]
                    series_number2 = l[j][2]
                    landmark_name2 = l[j][3]
                    landmark_coords2 = l[j][4]
                    
                    if  (patient_id1 == patient_id2) & (landmark_name1 == landmark_name2) & (accession_number1 != accession_number2): #matched landmark
                        if accession_number1 < accession_number2:
                            fixed = mha_directory+os.sep+patient_id1+'_'+str(accession_number1)+'_'+str(series_number1)+'_fixed.mha'
                            moving = mha_directory+os.sep+patient_id2+'_'+str(accession_number2)+'_'+str(series_number2)+'_moving.mha'
                            fixed_coords = landmark_coords1;
                            moving_coords = landmark_coords2;
                        else:
                            fixed = mha_directory+os.sep+patient_id2+'_'+str(accession_number2)+'_'+str(series_number2)+'_fixed.mha'
                            moving =mha_directory+os.sep+patient_id1+'_'+str(accession_number1)+'_'+str(series_number1)+'_moving.mha'
                            fixed_coords = landmark_coords2;
                            moving_coords = landmark_coords1;
                            
                        registration_tasklist.append([patient_id1,landmark_name1,fixed,fixed_coords,moving,moving_coords])    
                        break
    
    return registration_tasklist
    
    
def elastix_transformix_points_by_indices(transformix_exe,fixed_coords_in_pixel,TransformParameters_last_txt,output_directory):
    '''
    use elastix transformix executable to apply transformation by given input points pixel coordinates.
    note: The input points are specified in the fixed image domain (!), since the transformation direction is from fixed to moving image.
    '''
    import os
    import sys
    import subprocess
    
    #write inputPoints
    inputPoints = output_directory + os.sep + 'inputPoints.txt'
    f_inputPoints=open(inputPoints,'w')
    f_inputPoints.write('index\n') #in indices(pixel coordinates)
    f_inputPoints.write('1\n') # only 1 line
    f_inputPoints.write( str(fixed_coords_in_pixel).strip('[]').replace(',',' ') ) # [x,y,z] -> x y z
    f_inputPoints.close() 
   
    #do transformix: will write outputPoints.txt
    transformix_cmd = '"'+ transformix_exe +'"' + \
    ' -def ' + inputPoints + \
    ' -out ' + output_directory +\
    ' -tp ' + TransformParameters_last_txt
    
    transformix_cmd = subprocess.call(transformix_cmd)
    
    transformed_fixed_coords=[]
    if transformix_cmd == 0: #if success
        #extract outputPoints
        outputPoints = output_directory + os.sep + 'outputPoints.txt'
        f_outputPoints=open(outputPoints,'r')
        lines= f_outputPoints.readlines()
        lines=str(lines).split(';')
        OutputPoint = lines[4].split() #this is the transform PHYSICAL coordiantes
        transformed_fixed_coords = [float(i) for i in OutputPoint[3:6]]                
        f_outputPoints.close()    
    else:
        print("elastix_transformix_points_by_indices error")
        sys.exit(1)
        
    #clean
    os.remove(output_directory+os.sep+"inputPoints.txt")     
    os.remove(output_directory+os.sep+"outputPoints.txt")
    os.remove(output_directory+os.sep+"transformix.log")
        
    return transformed_fixed_coords    

def antsApplyTransformsToPoints(antsApplyTransformsToPoints_exe,moving_coords_in_physical,output_directory,output0GenericAffine_mat,ouput1InverseWarp_nii_gz):
    '''
    1. write ants_inputPoints.csv
    2. antsApplyTransformsToPoints -d 3 -i ants_inputPoints.csv -o ants_outputPoints.csv -t [output0GenericAffine_mat ,1 ] -t ouput1InverseWarp_nii_gz
    3. read ants_outputPoints.csv
    '''    

    import os
    import sys
    import subprocess
    
    
    #append 0: from antsApplyTransformsToPoints help: if you dont have 4D data, still supply 4D filling in extra spaces with zero
    moving_coords_in_physical_append_0 = moving_coords_in_physical[:]
    moving_coords_in_physical_append_0.append(0)
    
    #write inputPoints
    ants_inputPoints = output_directory + os.sep + 'ants_inputPoints.csv'
    f_inputPoints=open(ants_inputPoints,'w')
    f_inputPoints.write('x,y,z,t\n') # python will convert \n to os.linesep
    f_inputPoints.write( str(moving_coords_in_physical_append_0).strip('[]') ) # x,y,z,0
    f_inputPoints.write('\n') # python will convert \n to os.linesep
    f_inputPoints.close() # you can omit in most cases as the destructor will call it

    ants_outputPoints = output_directory + os.sep + 'ants_outputPoints.csv'

    #do transformix: will write outputPoints.txt
    antsApplyTransformsToPoints_cmd = antsApplyTransformsToPoints_exe + \
    ' -d 3 '+ \
    ' -i ' + ants_inputPoints + \
    ' -o ' + ants_outputPoints+ \
    ' -t [' + output0GenericAffine_mat + ', 1]' + \
    ' -t ' + ouput1InverseWarp_nii_gz
    
    antsApplyTransformsToPoints_cmd_result = subprocess.call(antsApplyTransformsToPoints_cmd)
    
    transformed_moving_coords = []
    if antsApplyTransformsToPoints_cmd_result == 0: #if sucesse
       #extract outputPoints
        f_outputPoints=open(ants_outputPoints,'r')
        lines= f_outputPoints.readlines()
        OutputPoint = lines[1].split(',') #this is the transform PHYSICAL coordiantes
        transformed_moving_coords = [float(i) for i in OutputPoint[0:3]]
        f_outputPoints.close()
    else:
        print("antsApplyTransformsToPoints error")
        sys.exit(0)
        
    #clean
    os.remove(ants_inputPoints)     
    os.remove(ants_outputPoints)    
    return transformed_moving_coords
    